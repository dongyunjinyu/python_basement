#################################################################
#########################    lambda     #########################
#################################################################
# 是一个重要的关键字，使用lambda能小幅缩减代码量
# 因为lambda所构成的函数只调用一次，不需要起名字，所以这个函数统称为 匿名函数

# 结构：
# lambda 参数1,参数2,…… : 带参返回值
lambda x,y:x+y
#这就是一个函数，他只能调用一次，所以如果不用东西接收它就直接消失了

# “接收” 就是给它起个名字：
func=lambda x,y:x+y
print(func(1,2))
#  >>3

# lambda也可以用来屏蔽一个函数
# 比如当你想试试让程序里的sleep函数全失效，看看是什么情况
# 就可以 time.sleep=lambda x:None
# 这样调用sleep函数就相当于啥也没发生

# 一般lambda是和需要用函数作为参数的函数一起用的：
# 比如：map   filter   reduce   sorted   property
# 接下来将重点讲解内置函数，讲解上面这几个函数时会大量使用lambda关键字


##################################################################
#########################    内置函数      #########################
##################################################################
# 先学习迭代器和生成器相关知识再食用风味更佳

###################
######  zip  ######
###################
# zip是一个迭代器，可以将 若干可迭代对象 顺位 压缩成 元组
# 比如当我们获得一个数据集，但是这一个数据集由多个部分组成，我们就可以用zip将多个部分合成
a='123'
b=[1,2,3,4]
c={'a':6,'b':7}
d=('kkk','lll','jjj')
print(list(zip(a,b,c,d)))
# >>[('1', 1, 'a', 'kkk'), ('2', 2, 'b', 'lll')]
# 这里abcd就是四个可迭代对象
# zip的返回值是迭代器本身，所以需要套一个list强制转化成列表，很多迭代器都是这样
# 迭代次数是 诸多可迭代对象中长度最短的长度，这里abcd的长度分别是3424，所以只迭代2次，返回的列表含有2个元组
# 循环拿出迭代器中对象，不需要list转换
for item in zip(a,b,c,d):
    print(item)
# >>('1', 1, 'a', 'kkk')
# >>('2', 2, 'b', 'lll')



######################
######  sorted  ######
######################
# sorted(__iterable,key,reverse)
# 这里面三个参数分别为：可迭代对象，键函数，反向
# sorted函数，可将 一个可迭代对象 按照给定的 键函数规则 进行排序，利用第三个参数指定升降序
lst1=[2,4,6,2,1,7,0]
print(sorted(lst1))
# >>[0, 1, 2, 2, 4, 6, 7]
# 可以看到，key的默认值是啥也不干，reverse的默认值是False也就是升序排序

print(sorted(lst1,reverse=True))
# >>[7, 6, 4, 2, 2, 1, 0]
# 可以看到，利用关键字传参，激活reverse参数，就降序排序了

# 但是如果可迭代对象的元素不是数字，或者我们想自定义排序规则，这时就要用到key参数了
# 键函数的参数只有一个，就是每次迭代给他的元素，键函数的返回值必须是数字类型
# 比如，我们这么设定：谁离5近算谁小
print(sorted(lst1,key=lambda x:x-5 if x-5>0 else 5-x))
# >>[4, 6, 7, 2, 2, 1, 0]

lst2=['哈','哈哈哈哈','哈哈','哈哈哈哈哈哈哈','哈哈哈']
print(sorted(lst2,key=lambda x:len(x),reverse=True))
# >>['哈哈哈哈哈哈哈', '哈哈哈哈', '哈哈哈','哈哈' , '哈']
# 这样我们就根据字符串长短进行了降序排序


######################
######  filter  ######
######################
# filter(__function,__iterable)
# filter函数用来筛选，__function指定筛选规则，__iterable是可迭代对象，注意他俩的顺序和sorted相反
# __function的参数是每一个迭代给他的元素，返回值必须为布尔值
# filter的本质是一个迭代器，要看数据需要用list转换
lst3=['张三','唐三','王五','张杰','PDD']
print(list(filter(lambda x:x.startswith('张'),lst3)))
# >>['张三', '张杰']
# 可以看出，如果元素传入lambda出来得到True，则保留

# 这个函数不能用关键字传参
# 在__function中合适的地方加上not可以将”筛选“变成”排除“
print(list(filter(lambda x:not x.startswith('张'), lst3)))
# >>['唐三', '王五', 'PDD']


###################
######  map  ######
###################
# 本质是一个迭代器，要看数据需要用list转换
lst4=[1,2,3,4,5,6]
print(list(map(lambda x:"{}的平方是{}".format(x,x*x),lst4)))
# >>['1的平方是1', '2的平方是4', '3的平方是9', '4的平方是16', '5的平方是25', '6的平方是36']
# map函数可将可迭代对象中的元素逐一拿出来执行函数，然后再按序放回迭代器
# map函数是相当常用的函数，尤其是在刷题时