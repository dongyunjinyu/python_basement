"""
本文件讲述：内存的相关知识

一个python程序的运行，主要需要计算机三大件的参与——  硬盘 -> 内存 -> CPU
我们所编写的代码或者从网上下载的代码是储存在硬盘中的
当我们去执行这些代码时，计算机会先把python解释器加载到内存中，python解释器实际上也是代码
然后我们要执行的代码，会被一行一行地加载给python解释器，由它来进行解释翻译，将翻译得到的二进制传递给CPU
然后CPU进行计算
计算的过程离不开内存的参与，因为内存是数据的栖息地，我们给出的、CPU计算得到的数据都会存到内存里
并且遵守一定的存储规则，以免存储数据过多过乱


用def来定义函数，先把函数的代码放到方法区内
一旦调用函数，就立马开辟一块内存，作为函数的栈帧，来储存函数内部的数据
函数调用完成之后，栈帧立刻销毁
"""
"""
for i in range(-10,300):
    print(i,'',id(i))

a=297
b=299
print(a is b)
print(id(a))
print(id(b))
"""
#我们用循环来输出-10到300的id值
#惊人的，-5到256，包括-5和256，他们的id是固定的，呈公差为32的等差数列递增
#而其他数字的id随着程序每一次运行，都是在变化的
#但是，，，奇葩的，，我不知道为什么奇数（偶数）的id打印出来是一样的
#我很疑惑，但是实际上肯定不可能多个数字占用同一块内存
#也确实没有占用同一块内存：
"""
for i in range(-10,0):
    print(i is i-2)
"""
#你看这个循环的结果就全是False，说明id根本不一样
############################################# 以后再考虑这个问题吧 ######################################



####################################################################
#########################  赋值 & 操作 & 内存图 #######################
####################################################################
# 形如 ？？=？？的代码叫赋值语句
# 形如 ？.append(？)的语句叫函数操作语句（自命名）


# 赋值语句的内存变化情况：

"""
a=10
"""
# 这是一个简单的赋值语句，整数 10 为一个对象，a 是一个引用，利用赋值语句，引用a指向了对象10；
# 对象也可以称之为值，引用也可以称之为变量，确实”引用——变量“这个称呼更加形象
# 这就相当于“放风筝”，变量a就是你手里面的“线”，python就跟那根“线”一样，通过引用来接触和拴住天空中的风筝——对象。
# 风筝至少得有一根线连着，一根也没有，那风筝就没了
# 就是说，如果我del a，那么a这个引用就被删除了，此时没有别的线牵着风筝，也就相当于10没了
# 既然是引用，那么我们平时说的调用a，其实是调用a所连接的对象
"""
del a
print(a)
"""
# 就会报错：NameError: name 'a' is not defined

# 恍然大悟了吗？那么给对象连上两根线，我们删一根，对象肯定还在，对吧
"""
a = '我是一个字符串对象'
b = a
del a
print(b)
"""
# >> 我是一个字符串对象

# 懂了吗！！！如果还不懂就动手拿张纸画图来看！！！不会画？笨！我画了几张内存图，去看“内存图1.ngm”文件！

# 诸如含有 = +=  -=  *=  /=  %= 的语句都是赋值语句
# 来，让我考考你懂没懂我上面说的赋值运算内存变化
a = 'hello'
a += 'world'
# 问，前后这两个a的内存是同一块内存吗？
# 不是
# 第一句，a=’hello‘ ，开辟一块内存储存’hello‘这个对象，这个对象被a引用，a是它的变量名
# 第二句，a = a + ’world‘ ，根据编程常识，我们先看等号右半边部分，再看左半边
# a + ’world‘ ，a是什么？a是一个引用，在这里就跟风筝线一样，a连着’hello‘
# 所以右半边实际是’hello‘ + ’world‘ ，对吧？得到的是’helloworld‘
# 然后，那么这个语句实际上就是 a = 'helloworld'
# 此时已经很显然了，'hello'和'helloworld'当然不可能是同一块内存
# 接下来，我们给'helloworld'，开辟一块内存，然后我们要求这块内存的变量也叫a
# 一根绳子只能连一个风筝吧，连俩也太不伦不类了，计算机可讨厌这种不伦不类的东西了
# 所以其实就是a不再引用‘hello’了，它转去引用'helloworld'了，此时，我们的'hello'没有绳子牵着了，他看起来就像是被删除了一般
# 当然实际上‘hello’还没有被删除，只是我们再也不能调用那个’hello‘了，因为我们手里没有绳子，风筝自由了
# 这个hello所占的内存由GC机制来回收，此处不再展开，感兴趣的话自己去搜吧
# 内存图见‘内存图2.ngm'文件


# 函数操作语句 的内存变化

# 他这个变化就跟赋值语句不同，否则也不会单独拿出来说，它操作的对象只能是 可变对象
# 可变对象就是不能哈希（hash）的对象，如 列表、字典
# 不可变对象就是可hash的对象， 如 整数、浮点数、元组、字符串

# 函数操作语句 只能操作可变对象，如列表的.append()函数语句，就直接在对象上进行操作而不是新创建一个对象
#                                                   -------------------------------上面这句话是精髓
#操作可变对象就好像是直接给对象做手术，而操作不可变对象就好像是先把对象镜像一份，给它的镜像做手术
#直接体现在：
"""
a='hello'
b=a+'world'
print(a)
print(b)
c=[1,2,3]
d=c
d.append(4)
print(c)
print(d)
"""
#  >> hello
#  >> helloworld
#  >> [1, 2, 3, 4]
#  >> [1, 2, 3, 4]

# 看见没，c和d都成了[1, 2, 3, 4]，而a还是a ；b是新创建的
# 内存图见“内存图3.ngm”

#################################################################
# 好了，现在我们就能理解下面这个问题了

# 众所周知，在一个函数内部，称之为”局部“，那么在局部中，不用global还能修改全局变量吗？
# 可以 只能修改 可变对象  看下面两个对比
# ######  gl_  是用来标注这个变量是全局变量

gl_num=10
def han():
    aaa=gl_num
    aaa+=10
han()
print(gl_num)

gl_arr=[1,2,3]
def shu():
    bbb=gl_arr
    bbb.append(4)
shu()
print(gl_arr)

# >> 10
# >> [1,2,3,4]
# 你看，gl_num还是10 ，gl_arr却变成了[1,2,3,4]
# 第二个例子不就是局部修改全局变量吗
# 之所以能办到，就是因为列表是可变的，我们进行的操作是直接在对象上进行
# 内存图见”内存图4.ngm“

# 是不是恍然大悟，现在你明白：为什么字符串相关的函数，如title、capitalize等 都是需要一个返回值来接收的
#                            而列表相关的函数，如append、sort等 都是不用接收直接变化的            了吗

#你会画内存图了吗，带上global 、return 的函数的内存图你应该也会画了吧，去画画试试，用”引用——对象“的思路画






##############################################################################################

#############################    python中，一切皆对象   #########################################