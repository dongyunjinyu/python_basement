#本教程学习前先学习内存知识再食用口味更佳

#####################################################
#################  函数的本质   #######################
#函数是一种新的数据类型，名叫function
a=9  # 一个全局变量
def fun():
    print(a)
    return a

print(type(fun))
#  >> <class 'function'>

#（）前的函数名其实就是一个变量；它的值是函数的内容，就是一堆代码
nuf=fun
#这样就相当于把fun（）函数的内容（包括参数、函数体）赋值给变量nuf，这样nuf也成了一个function
nuf()
#  >> 9

print(nuf)
#  >> <function fun at 0x000001AB1A1A71F0>
print(fun)
#  >> <function fun at 0x000001AB1A1A71F0>
#可以看到，实际上nuf和fun指向的是一片内存，只是这个函数，有两个名字能指代它，一个是fun另一个是nuf
#那么可以直接判定，nuf==fun和nuf is fun都是真的
print(nuf == fun and nuf is fun)
#  >>True
# 果然是真的
print('-------------------------')

###########################################
#################  生命周期  ################
###########################################
# 变量具有生命周期，很形象的一个词，变量出生（分配给它一块内存）到死亡（从内存中将它移除）的时间
# 全局变量的出生是在程序运行到定义变量的时候
# 全局变量的死亡是在 del之后，如果没有del则整个程序执行完成时所有变量死亡
# 局部变量的出生是在函数被调用且变量被定义时
# 局部变量的死亡是在函数执行完成之后
# 每当函数被调用，内存中划出一块地作为函数的栈帧
# 局部变量在这个栈帧中生存，如果你在函数调用时就del它了，它很短命
# 因为局部变量是在函数执行完成之后栈帧崩溃时才会死亡
# 如何让一个局部变量在栈帧崩溃时不死？？？   闭包（见后面）

# 当我们点击运行程序，程序运行到这时
aa=10  #开辟一块内存，储存10这个值，空间的名字叫aa
def hanshu(): # 运行到这里，将函数放到方法区里
    b=20
hanshu() #运行到这里时，从方法区里调用函数hanshu（），给函数开辟一个块内存叫栈帧，再在栈帧内开辟一小块内存，储存20这个值，这一块内存的名字叫b
# 运行到这里时，hanshu（）已经执行完毕，系统自动回收栈帧，自然里面的b=20也没了，但是aa=10却一直在，直到整个程序执行完毕，aa=10才被回收；这就是所谓 局部变量与全局变量

#############################################################################################
#########################  赋值 & 操作 & 内存图 & 本来就可以从局部修改全局变量 #######################
#############################################################################################
# 由于这一块篇幅过长
# 请移步至”内存.py“文件浏览



#####################################################################
#################  global & nonlocal  ###############################
#####################################################################

#在函数中无法直接修改全局变量，相当于只有可读权限
#关键字 global ：先用global引入想修改的全局变量，就可以修改全局变量了，相当于拥有了可写权限

#用global前：
A='哈哈哈'
def funcA():
    A='呵呵呵'
    print(A)
funcA()
print(A)
#  >> 呵呵呵
#  >> 哈哈哈

#用global之后：
A='哈哈哈'
def funcA():
    global A
    A='呵呵呵'
    print(A)
funcA()
print(A)
#  >>呵呵呵
#  >>呵呵呵
# 就实现了在函数中修改了全局变量这一操作
print('-------------------------')


#关键字 nonlocal ：可以在局部引入向外一层中的变量,如果外一层没找到就再外一层……
#如果我们还用global：
def funcA():
     S="哈哈哈"
     def funcB():
        global S
        S='呵呵呵'
        print(S)
     funcB()
     print(S)
funcA()
#  >> 呵呵呵
#  >> 哈哈哈
#这里假设想在funcB函数中修改S的值，如果用global，改不了，因为全局中并没有S这个变量
#应该把global换成nonlocal
def funcA():
    S = "哈哈哈"
    def funcB():
        nonlocal S
        S = '呵呵呵'
        print(S)
    funcB()
    print(S)
funcA()
#  >> 呵呵呵
#  >> 呵呵呵
#这是两个函数进行嵌套
#如果是三层嵌套，第三层想修改第一层的变量，就需要确保第二层中没有同名变量，这样nonlocal才会一直找到第一层中去

#所以去修改一个变量首先得知道这个变量名，如果知道了也就不会出现nonlocal找错地方的尴尬局面
#一旦找错地方，那就修改错地方了，那整个程序就崩了（程序依靠bug运行除外哈哈）
#所以得避免修改 或 安全地修改，怎么做？   闭包


######################################################
####################  闭包  ###########################
######################################################
# 作用:
#     1.可以让一个变量常驻内存
#     2.可以在全局中修改局部变量，避免全局变量被修改/污染

#格式：
def func():
    pass
    def inner():
        pass
    pass
    return inner
#调用：
func()()
#或者：
func1=func()   #func（）的返回值是inner函数
func1()      #实际就是调用了inner函数，实现了：在全局中调用局部的东西
# func1=inner   这么写是错的，调用不到inner，上面之所以能调用得到inner是因为inner是返回值
# 正是inner作为了返回值，才使内层函数能被外层函数所调用