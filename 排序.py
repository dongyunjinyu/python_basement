###########################################################################################################
###############################      排序算法详解与python代码实现      #########################################
###############################      作者:孙海鑫  苏州大学未来学院      #########################################
###########################################################################################################

#########################
### 准备阶段，定义一些函数 ###
#########################

######  生成随机数列，用来实现算法   ######
from random import randint #从random库里导入randit函数，如果是import*就是导入所有函数
#randint(min,max)的返回值为min~max的一个随机数，包括min和max
def randArr(min,max,n): #该函数返回一个列表形式的数列，含有n个整数，范围min~max
    return [randint(min,max)for x in range(n)]

######  生成有序的数列   ######
def orderedArr(min,max):
    return [i for i in range(min,max+1)] #返回一个有序连续数列，如：3456789

######  生成基本有序的数列    ########
def nearlyOrdArr(min,max,swapTime):
    arr=[i for i in range(min,max+1)] #得到一个有序的数列。如：3456789
    for j in range(swapTime): #对换j次
        posix=randint(0,max-min) #随机地得到被对换元素的位置
        posiy=randint(0,max-min)
        arr[posix],arr[posiy]=arr[posiy],arr[posix] #对换
    return arr #返回被对换j次后的数列

########   判断一个数列是否升序排列（是否有序）  #######
def isSorted(lst):
    for i in range(len(lst)-1):  #迭代
        if lst[i]>lst[i+1]:  #一旦出现前一项大于后一项的情况
            return False  #直接判定为无序，返回false结束程序
    return True  #迭代完后，一直没有出现逆序的情况，视为True，13579也是True


#########   判断算法是否排序成功  不成功就报错    ########
def testSort(func, alist):   #func表示要检测的算法函数，alist为传入的数列
    alist=func(alist) #需要定义全局变量alist，在运行时间标准检验阶段，我们定义的全局变量为randArr(0,9,20)
    assert isSorted(alist), "排序算法错误\n"  # assert 后的表示式的值若为False，则报错，并提示报错信息

##################################################################################################################
######################################   正式阶段，下面式是经典的排序算法   #############################################
##################################################################################################################


###################################   冒泡排序   ####################################
def bubbleSort(alist):
    n = len(alist)
    for i in range(n-1, 0, -1): #假设n=10，则 i=9，8，7，6，5，4，3，2，1，0
        for j in range(0, i): #通过遍历，使第i位为数列中最大的数
            if alist[j] > alist[j+1]:
                alist[j], alist[j+1] = alist[j+1], alist[j]
    return alist
####################################################################################


##################################














##############################################################################
##########   运行时间标准检验阶段   以一个有20个0~9随机排列的数组为检测基准     ##########
##############################################################################
import timeit
alist=randArr(0,9,20)  #生成随机数列，用来检测算法运行时间
t=timeit.Timer('testSort(#####, alist)', 'from __main__ import testSort, ######, alist') #设置计时器
#例：检验冒泡排序的运行时间：将上一行的两处“#####”替换为“bubbleSort”，注意没有引号，然后运行
print(f'该排序算法运行时间：{t.timeit(number=100000)} s')  #打印:该排序运行十万次所花费的时间